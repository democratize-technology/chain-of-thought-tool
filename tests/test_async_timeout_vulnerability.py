"""
Test for critical async timeout vulnerability in Bedrock integration.

This test demonstrates the missing timeout handling in AsyncChainOfThoughtProcessor
which can cause hanging requests and resource exhaustion.

Fails BEFORE fix, passes AFTER fix.
"""
import pytest
import asyncio
import time
from unittest.mock import MagicMock, patch
from chain_of_thought.core import AsyncChainOfThoughtProcessor
from chain_of_thought.security import SecurityConfig, RequestValidator


@pytest.mark.security
@pytest.mark.async_timeout
class TestAsyncTimeoutVulnerability:
    """Test critical async timeout vulnerabilities in Bedrock integration."""

    def setup_method(self):
        """Set up test processor with test security config."""
        self.test_security_config = SecurityConfig()
        self.test_security_config.allowed_model_patterns = [r"test\.model\..*"]
        self.test_security_config.max_max_tokens = 5000
        self.test_security_config.max_temperature = 2.0
        self.test_security_config.max_top_p = 1.0

        # Create custom validator with test config
        self.test_validator = RequestValidator(self.test_security_config)
        self.processor = AsyncChainOfThoughtProcessor(
            conversation_id="test_conversation",
            request_validator=self.test_validator
        )

    def test_timeout_protection_working(self):
        """
        TEST: Verify timeout protection is working correctly.

        This demonstrates that hanging AWS calls are properly handled.
        """
        # Create processor with very short timeout
        fast_processor = AsyncChainOfThoughtProcessor(
            conversation_id="timeout_test",
            request_validator=self.test_validator,
            aws_call_timeout=0.5,  # Very short timeout
            tool_call_timeout=0.5
        )

        # Mock bedrock client that takes too long
        slow_client = MagicMock()

        def slow_converse(**kwargs):
            # Use time.sleep for synchronous function (run_in_executor context)
            time.sleep(1.0)  # Longer than timeout
            return {
                "stopReason": "end_turn",
                "output": {"message": {"content": [{"text": "slow response"}]}}
            }

        slow_client.converse.side_effect = slow_converse

        request = {
            "modelId": "test.model.anthropic",
            "messages": [{"role": "user", "content": [{"text": "test"}]}],
            "system": [{"text": "test system"}]
        }

        async def test_timeout_handling():
            start_time = asyncio.get_event_loop().time()

            # This should timeout quickly and raise TimeoutError
            with pytest.raises(TimeoutError, match="AWS Bedrock call timed out after 0.5 seconds"):
                await fast_processor.process_tool_loop(slow_client, request, max_iterations=1)

            elapsed = asyncio.get_event_loop().time() - start_time

            # Should fail quickly due to timeout protection (not wait the full 1 second)
            assert elapsed < 0.8, f"Request took {elapsed}s, should timeout much faster"

        # Test timeout protection works
        loop = asyncio.get_event_loop()
        loop.run_until_complete(test_timeout_handling())

        print("✅ Timeout protection is working correctly")

    async def test_aws_call_timeout_protection(self):
        """
        Test that AWS calls have proper timeout protection.
        """
        # Mock bedrock client with delay
        slow_client = MagicMock()

        # Simulate a slow AWS call (5 seconds)
        async def slow_converse(**kwargs):
            await asyncio.sleep(5.0)  # Simulate slow network
            return {
                "stopReason": "end_turn",
                "output": {"message": {"content": [{"text": "slow response"}]}}
            }

        slow_client.converse.side_effect = slow_converse

        request = {
            "modelId": "test.model.anthropic",
            "messages": [{"role": "user", "content": [{"text": "test"}]}],
            "system": [{"text": "test system"}]
        }

        start_time = asyncio.get_event_loop().time()

        # This should timeout quickly with proper timeout handling
        result = await self.processor.process_tool_loop(
            slow_client,
            request,
            max_iterations=1
        )

        elapsed = asyncio.get_event_loop().time() - start_time

        # Should complete quickly with timeout (not wait the full 5 seconds)
        assert elapsed < 3.0, f"Request took {elapsed}s, should timeout much faster"
        assert result is not None, "Should return result on timeout"

    async def test_tool_call_timeout_protection(self):
        """
        Test that tool calls within the loop have timeout protection.
        """
        # Mock bedrock client that responds with tool use
        tool_client = MagicMock()

        tool_client.converse.return_value = {
            "stopReason": "tool_use",
            "output": {
                "message": {
                    "content": [
                        {
                            "toolUse": {
                                "name": "chain_of_thought_step",
                                "input": {"thought": "test", "step_number": 1, "total_steps": 1, "next_step_needed": False}
                            }
                        }
                    ]
                }
            }
        }

        # Mock a slow handler that hangs
        async def slow_handler(**kwargs):
            await asyncio.sleep(10.0)  # Very slow handler
            return {"status": "success", "step_processed": 1}

        with patch('chain_of_thought.core.create_chain_of_thought_step_handler') as mock_handler:
            mock_handler.return_value = slow_handler

            request = {
                "modelId": "test.model.anthropic",
                "messages": [{"role": "user", "content": [{"text": "test"}]}],
                "system": [{"text": "test system"}]
            }

            start_time = asyncio.get_event_loop().time()

            # This should timeout on the slow handler call
            result = await self.processor.process_tool_loop(
                tool_client,
                request,
                max_iterations=1
            )

            elapsed = asyncio.get_event_loop().time() - start_time

            # Should timeout quickly, not wait 10 seconds
            assert elapsed < 5.0, f"Tool call took {elapsed}s, should timeout much faster"

    async def test_multiple_iteration_timeout_handling(self):
        """
        Test timeout handling across multiple iterations of the tool loop.
        """
        # Create a client that's slow on the second call
        iteration_count = 0
        def variable_converse(**kwargs):
            nonlocal iteration_count
            iteration_count += 1

            if iteration_count == 1:
                # Fast first response
                return {
                    "stopReason": "tool_use",
                    "output": {
                        "message": {
                            "content": [
                                {
                                    "toolUse": {
                                        "name": "chain_of_thought_step",
                                        "input": {"thought": "test", "step_number": 1, "total_steps": 2, "next_step_needed": True}
                                    }
                                }
                            ]
                        }
                    }
                }
            else:
                # Hang on second call
                return asyncio.Future()  # Never completes

        slow_client = MagicMock()
        slow_client.converse.side_effect = variable_converse

        async def fast_handler(**kwargs):
            return {"status": "success", "step_processed": 1}

        with patch('chain_of_thought.core.create_chain_of_thought_step_handler') as mock_handler:
            mock_handler.return_value = fast_handler

            request = {
                "modelId": "test.model.anthropic",
                "messages": [{"role": "user", "content": [{"text": "test"}]}],
                "system": [{"text": "test system"}]
            }

            start_time = asyncio.get_event_loop().time()

            # Should timeout on second iteration
            result = await self.processor.process_tool_loop(
                slow_client,
                request,
                max_iterations=3
            )

            elapsed = asyncio.get_event_loop().time() - start_time

            # Should complete in reasonable time due to timeout protection
            assert elapsed < 10.0, f"Multiple iterations took {elapsed}s, should timeout on slow iteration"
            assert iteration_count >= 2, "Should have reached the slow iteration"

    def test_timeout_configuration_respected(self):
        """
        Test that timeout configuration is properly respected.
        """
        # Test with custom timeout settings
        custom_processor = AsyncChainOfThoughtProcessor(
            conversation_id="test_custom_timeout",
            request_validator=self.test_validator
        )

        # Mock slow client
        slow_client = MagicMock()

        async def very_slow_converse(**kwargs):
            await asyncio.sleep(2.0)  # Longer than timeout
            return {"stopReason": "end_turn"}

        slow_client.converse.side_effect = very_slow_converse

        request = {
            "modelId": "test.model.anthropic",
            "messages": [{"role": "user", "content": [{"text": "test"}]}],
            "system": [{"text": "test system"}]
        }

        async def test_timeout():
            start_time = asyncio.get_event_loop().time()

            result = await custom_processor.process_tool_loop(
                slow_client,
                request,
                max_iterations=1
            )

            elapsed = asyncio.get_event_loop().time() - start_time

            # Should timeout much faster than 2 seconds
            assert elapsed < 1.5, f"Custom timeout not respected: took {elapsed}s"
            assert result is not None, "Should handle timeout gracefully"

        # Run the test
        loop = asyncio.get_event_loop()
        loop.run_until_complete(test_timeout())


if __name__ == "__main__":
    # Run standalone test
    test_instance = TestAsyncTimeoutVulnerability()
    test_instance.setup_method()

    try:
        test_instance.test_missing_timeout_in_run_in_executor_vulnerability()
        print("✅ Timeout vulnerability test PASSED")
    except AssertionError as e:
        print(f"❌ Timeout vulnerability test FAILED: {e}")
    except Exception as e:
        print(f"❌ Test error: {e}")