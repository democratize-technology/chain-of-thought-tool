"""
Test for critical async timeout vulnerability in Bedrock integration.

This test demonstrates the missing timeout handling in AsyncChainOfThoughtProcessor
which can cause hanging requests and resource exhaustion.

Fails BEFORE fix, passes AFTER fix.
"""
import pytest
import asyncio
import time
from unittest.mock import MagicMock, patch
from chain_of_thought.core import AsyncChainOfThoughtProcessor
from chain_of_thought.security import SecurityConfig, RequestValidator


@pytest.mark.security
@pytest.mark.async_timeout
class TestAsyncTimeoutVulnerability:
    """Test critical async timeout vulnerabilities in Bedrock integration."""

    def setup_method(self):
        """Set up test processor with test security config."""
        self.test_security_config = SecurityConfig()
        self.test_security_config.allowed_model_patterns = [r"test\.model\..*"]
        self.test_security_config.max_max_tokens = 5000
        self.test_security_config.max_temperature = 2.0
        self.test_security_config.max_top_p = 1.0

        # Create custom validator with test config
        self.test_validator = RequestValidator(self.test_security_config)
        self.processor = AsyncChainOfThoughtProcessor(
            conversation_id="test_conversation",
            request_validator=self.test_validator
        )

    def test_timeout_protection_working(self):
        """
        TEST: Verify timeout protection is working correctly.

        This demonstrates that hanging AWS calls are properly handled.
        """
        # Create processor with very short timeout for testing
        fast_processor = AsyncChainOfThoughtProcessor(
            conversation_id="timeout_test",
            request_validator=self.test_validator,
            aws_call_timeout=0.5,  # Very short timeout
            tool_call_timeout=0.5
        )

        # Mock bedrock client that takes too long
        slow_client = MagicMock()

        def slow_converse(**kwargs):
            # Use time.sleep for synchronous function (run_in_executor context)
            time.sleep(1.0)  # Longer than timeout
            return {
                "stopReason": "end_turn",
                "output": {"message": {"content": [{"text": "slow response"}]}}
            }

        slow_client.converse.side_effect = slow_converse

        request = {
            "modelId": "test.model.anthropic",
            "messages": [{"role": "user", "content": [{"text": "test"}]}],
            "system": [{"text": "test system"}]
        }

        async def test_timeout_handling():
            start_time = asyncio.get_event_loop().time()

            # This should timeout quickly and raise TimeoutError
            with pytest.raises(TimeoutError, match="AWS Bedrock call timed out after 0.5 seconds"):
                await fast_processor.process_tool_loop(slow_client, request, max_iterations=1)

            elapsed = asyncio.get_event_loop().time() - start_time

            # Should fail quickly due to timeout protection (not wait the full 1 second)
            assert elapsed < 0.8, f"Request took {elapsed}s, should timeout much faster"

        # Test timeout protection works
        loop = asyncio.get_event_loop()
        loop.run_until_complete(test_timeout_handling())

        print("✅ Timeout protection is working correctly")

    @pytest.mark.asyncio
    async def test_aws_call_timeout_protection(self):
        """
        Test that AWS calls have proper timeout protection.
        """
        # Mock bedrock client with delay
        slow_client = MagicMock()

        # Simulate a slow AWS call (5 seconds)
        def slow_converse(**kwargs):
            import time
            time.sleep(5.0)  # Simulate slow network
            return {
                "stopReason": "end_turn",
                "output": {"message": {"content": [{"text": "slow response"}]}}
            }

        slow_client.converse = slow_converse

        request = {
            "modelId": "test.model.anthropic",
            "messages": [{"role": "user", "content": [{"text": "test"}]}],
            "system": [{"text": "test system"}]
        }

        start_time = asyncio.get_event_loop().time()

        # Create processor with short timeout for testing
        fast_processor = AsyncChainOfThoughtProcessor(
            conversation_id="aws_timeout_test",
            request_validator=self.test_validator,
            aws_call_timeout=1.0  # Short timeout
        )

        # This should timeout quickly with proper timeout handling
        with pytest.raises(TimeoutError, match="AWS Bedrock call timed out after 1.0 seconds"):
            result = await fast_processor.process_tool_loop(
                slow_client,
                request,
                max_iterations=1
            )

        elapsed = asyncio.get_event_loop().time() - start_time

        # Should complete quickly with timeout (not wait the full 5 seconds)
        assert elapsed < 2.0, f"Request took {elapsed}s, should timeout much faster"

    @pytest.mark.asyncio
    async def test_tool_call_timeout_protection(self):
        """
        Test that tool calls within the loop have timeout protection.
        """
        # Mock bedrock client that responds with tool use
        tool_client = MagicMock()

        tool_client.converse.return_value = {
            "stopReason": "tool_use",
            "output": {
                "message": {
                    "content": [
                        {
                            "toolUse": {
                                "toolUseId": "test-tool-id",
                                "name": "chain_of_thought_step",
                                "input": {"thought": "test", "step_number": 1, "total_steps": 1, "next_step_needed": False}
                            }
                        }
                    ]
                }
            }
        }

        # Create processor with short timeout for testing
        fast_processor = AsyncChainOfThoughtProcessor(
            conversation_id="tool_timeout_test",
            request_validator=self.test_validator,
            tool_call_timeout=1.0  # Short timeout
        )

        # Mock a slow handler that hangs
        async def slow_handler(**kwargs):
            await asyncio.sleep(5.0)  # Slower than timeout
            return {"status": "success", "step_processed": 1}

        with patch('chain_of_thought.core.create_chain_of_thought_step_handler') as mock_handler:
            mock_handler.return_value = slow_handler

            request = {
                "modelId": "test.model.anthropic",
                "messages": [{"role": "user", "content": [{"text": "test"}]}],
                "system": [{"text": "test system"}]
            }

            start_time = asyncio.get_event_loop().time()

            # This should timeout on the slow handler call but continue with error result
            result = await fast_processor.process_tool_loop(
                tool_client,
                request,
                max_iterations=1
            )

            elapsed = asyncio.get_event_loop().time() - start_time

            # Should complete quickly with timeout handling (not wait 5 seconds)
            assert elapsed < 2.0, f"Tool call took {elapsed}s, should timeout much faster"

            # Should return a result with error information from the timeout
            assert result is not None, "Should return result even with tool timeout"
            assert "stopReason" in result, "Should have stopReason in result"

    @pytest.mark.asyncio
    async def test_multiple_iteration_timeout_handling(self):
        """
        Test timeout handling across multiple iterations of the tool loop.
        """
        # Create a client that's slow on the second call
        iteration_count = 0
        def variable_converse(**kwargs):
            nonlocal iteration_count
            iteration_count += 1

            if iteration_count == 1:
                # Fast first response
                return {
                    "stopReason": "tool_use",
                    "output": {
                        "message": {
                            "content": [
                                {
                                    "toolUse": {
                                        "toolUseId": "test-tool-id-1",
                                        "name": "chain_of_thought_step",
                                        "input": {"thought": "test", "step_number": 1, "total_steps": 2, "next_step_needed": True}
                                    }
                                }
                            ]
                        }
                    }
                }
            else:
                # Hang on second call
                import time
                time.sleep(10.0)  # Longer than timeout
                return {"stopReason": "end_turn"}

        slow_client = MagicMock()

        # Create a wrapper that uses the counter function
        def converse_wrapper(**kwargs):
            return variable_converse(**kwargs)

        slow_client.converse = converse_wrapper

        # Create processor with short timeout for testing
        fast_processor = AsyncChainOfThoughtProcessor(
            conversation_id="iteration_timeout_test",
            request_validator=self.test_validator,
            aws_call_timeout=2.0  # Short timeout
        )

        async def fast_handler(**kwargs):
            return {"status": "success", "step_processed": 1}

        with patch('chain_of_thought.core.create_chain_of_thought_step_handler') as mock_handler:
            mock_handler.return_value = fast_handler

            request = {
                "modelId": "test.model.anthropic",
                "messages": [{"role": "user", "content": [{"text": "test"}]}],
                "system": [{"text": "test system"}]
            }

            start_time = asyncio.get_event_loop().time()

            # Should timeout on second iteration
            with pytest.raises(TimeoutError, match="AWS Bedrock call timed out after 2.0 seconds"):
                result = await fast_processor.process_tool_loop(
                    slow_client,
                    request,
                    max_iterations=3
                )

            elapsed = asyncio.get_event_loop().time() - start_time

            # Should complete quickly due to timeout protection
            assert elapsed < 4.0, f"Multiple iterations took {elapsed}s, should timeout on slow iteration"
            assert iteration_count >= 2, "Should have reached the slow iteration"

    def test_timeout_configuration_respected(self):
        """
        Test that timeout configuration is properly respected.
        """
        # Test with custom timeout settings
        custom_processor = AsyncChainOfThoughtProcessor(
            conversation_id="test_custom_timeout",
            request_validator=self.test_validator,
            aws_call_timeout=1.0  # Set timeout to 1 second
        )

        # Mock slow client
        slow_client = MagicMock()

        def very_slow_converse(**kwargs):
            # Simulate slow synchronous call
            import time
            time.sleep(2.0)  # Longer than timeout
            return {"stopReason": "end_turn"}

        slow_client.converse = very_slow_converse

        request = {
            "modelId": "test.model.anthropic",
            "messages": [{"role": "user", "content": [{"text": "test"}]}],
            "system": [{"text": "test system"}]
        }

        async def test_timeout():
            start_time = asyncio.get_event_loop().time()

            # Should timeout quickly and raise TimeoutError
            with pytest.raises(TimeoutError, match="AWS Bedrock call timed out after 1.0 seconds"):
                await custom_processor.process_tool_loop(
                    slow_client,
                    request,
                    max_iterations=1
                )

            elapsed = asyncio.get_event_loop().time() - start_time

            # Should timeout much faster than 2 seconds
            assert elapsed < 1.5, f"Custom timeout not respected: took {elapsed}s"

        # Run the test
        loop = asyncio.get_event_loop()
        loop.run_until_complete(test_timeout())


if __name__ == "__main__":
    # Run standalone test
    test_instance = TestAsyncTimeoutVulnerability()
    test_instance.setup_method()

    try:
        test_instance.test_missing_timeout_in_run_in_executor_vulnerability()
        print("✅ Timeout vulnerability test PASSED")
    except AssertionError as e:
        print(f"❌ Timeout vulnerability test FAILED: {e}")
    except Exception as e:
        print(f"❌ Test error: {e}")