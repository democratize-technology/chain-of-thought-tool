"""
Test for critical JSON serialization security vulnerability.

This test demonstrates the unsafe _safe_json_dumps function that can expose:
1. Internal data structures via __dict__
2. Error types that reveal internal implementation details
3. Sensitive data through unchecked serialization

Fails BEFORE fix, passes AFTER fix.
"""
import pytest
import json
from dataclasses import dataclass
from chain_of_thought.core import _safe_json_dumps


@pytest.mark.security
@pytest.mark.json_vulnerability
class TestJSONSerializationVulnerability:
    """Test critical JSON serialization security vulnerabilities."""

    def test_unsafe_dict_serialization_exposes_internal_state(self):
        """
        VULNERABILITY: _safe_json_dumps exposes internal object state via __dict__

        This demonstrates how sensitive internal data can be exposed.
        """
        @dataclass
        class SecretData:
            api_key: str = "sk-1234567890abcdef"
            secret_token: str = "token_super_secret"
            password: str = "admin123"

        secret = SecretData()

        # This should NOT expose sensitive data
        result = _safe_json_dumps(secret)
        data = json.loads(result)

        print(f"Serialized data: {data}")

        # VULNERABILITY: Should NOT contain sensitive internal data
        # BEFORE FIX: Will expose api_key, secret_token, password
        # AFTER FIX: Should be sanitized
        assert "api_key" not in str(data), "CRITICAL: API key exposed in serialization"
        assert "secret_token" not in str(data), "CRITICAL: Secret token exposed in serialization"
        assert "password" not in str(data), "CRITICAL: Password exposed in serialization"

        # Should return safe, generic data instead
        if "status" in data:
            assert data.get("status") in ["success", "error"], "Unexpected status value"

    def test_error_type_exposes_internal_details(self):
        """
        VULNERABILITY: _safe_json_dumps exposes internal error types

        This demonstrates how error types can reveal internal implementation.
        """
        # Create object that will cause TypeError
        class ProblematicObject:
            def __str__(self):
                raise TypeError("Cannot convert this object")

        problematic = ProblematicObject()

        # This should NOT expose internal error types
        result = _safe_json_dumps(problematic)

        print(f"Error serialization result: {result}")

        # Try to parse as JSON first
        try:
            data = json.loads(result)
            is_json = True
        except json.JSONDecodeError:
            data = result
            is_json = False

        # VULNERABILITY: Should NOT expose internal error types
        # BEFORE FIX: Will reveal "TypeError", "ValueError", etc.
        # AFTER FIX: Should be sanitized object or generic error
        if is_json and isinstance(data, dict) and data.get("status") == "error":
            assert "error_type" not in data, "CRITICAL: Internal error type exposed"
            assert "TypeError" not in str(data), "CRITICAL: TypeError name exposed"
            assert "ValueError" not in str(data), "CRITICAL: ValueError name exposed"
            assert "OverflowError" not in str(data), "CRITICAL: OverflowError name exposed"

            # Should have generic error message
            assert data.get("message") == "Data processing failed", "Expected generic error message"
        else:
            # Should be sanitized object representation, not error details
            assert "[Object: ProblematicObject]" in str(data), "Expected sanitized object representation"
            assert "TypeError" not in str(data), "CRITICAL: TypeError exposed in output"
            assert "Cannot convert this object" not in str(data), "CRITICAL: Internal error message exposed"

    def test_sensitive_key_filtering_missing(self):
        """
        VULNERABILITY: _safe_json_dumps doesn't filter sensitive keys

        This demonstrates how sensitive data keys are not filtered.
        """
        # Dictionary with sensitive keys
        sensitive_dict = {
            "user_id": 123,
            "username": "test_user",
            "password": "super_secret_password",
            "api_key": "sk-live-abcdef123456",
            "credit_card": "4111-1111-1111-1111",
            "ssn": "123-45-6789",
            "auth_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
            "normal_field": "normal_value"
        }

        result = _safe_json_dumps(sensitive_dict)
        data = json.loads(result)

        print(f"Sensitive dict serialization: {data}")

        # SECURITY: Should NOT expose actual sensitive data values
        # BEFORE FIX: Will expose all sensitive key values
        # AFTER FIX: Should redact sensitive values
        sensitive_keys = ["password", "api_key", "credit_card", "ssn", "auth_token", "secret", "token", "key"]

        for key in sensitive_keys:
            if key in data:
                value = str(data[key])
                # Should be redacted, not actual sensitive data
                assert value == "[REDACTED]", f"CRITICAL: Sensitive key '{key}' not properly redacted: {value}"
                # Should not contain original sensitive patterns
                assert "super_secret" not in value, f"CRITICAL: Original sensitive data exposed in '{key}'"
                assert "sk-live" not in value, f"CRITICAL: Original API key exposed in '{key}'"
                assert "4111-1111" not in value, f"CRITICAL: Original credit card exposed in '{key}'"
                assert "123-45" not in value, f"CRITICAL: Original SSN exposed in '{key}'"
                assert "eyJhbGci" not in value, f"CRITICAL: Original token exposed in '{key}'"

        # Non-sensitive fields should remain intact
        assert data["user_id"] == 123, "Non-sensitive field should be preserved"
        assert data["username"] == "test_user", "Non-sensitive field should be preserved"
        assert data["normal_field"] == "normal_value", "Non-sensitive field should be preserved"

    def test_uncontrolled_serialization_depth(self):
        """
        VULNERABILITY: _safe_json_dumps can serialize unlimited object depth

        This demonstrates potential for serialization attacks through deep nesting.
        """
        # Create deeply nested structure that could cause issues
        deep_data = {"level": 0}
        current = deep_data
        for i in range(1, 1000):  # Very deep nesting
            current["nested"] = {"level": i}
            current = current["nested"]

        # This should handle depth safely
        result = _safe_json_dumps(deep_data)
        data = json.loads(result)

        print(f"Deep serialization result length: {len(result)}")

        # Should not be unreasonably large or cause issues
        assert len(result) < 100000, "Serialization too large - potential DoS vector"
        assert json.loads(result) is not None, "Invalid JSON produced"

    def test_no_control_over_safe_types(self):
        """
        VULNERABILITY: _safe_json_dumps doesn't use whitelist approach

        This demonstrates how dangerous object types can be serialized.
        """
        # Object with potentially dangerous methods
        class DangerousObject:
            def __init__(self):
                self.eval_code = "__import__('os').system('rm -rf /')"
                self.system_command = "cat /etc/passwd"
                self.sql_injection = "'; DROP TABLE users; --"

        dangerous = DangerousObject()

        result = _safe_json_dumps(dangerous)
        data = json.loads(result)

        print(f"Dangerous object serialization: {data}")

        # VULNERABILITY: Should NOT serialize dangerous content
        # BEFORE FIX: Will expose dangerous strings
        # AFTER FIX: Should sanitize or block dangerous content
        dangerous_patterns = ["eval_code", "system_command", "sql_injection", "__import__", "DROP TABLE"]

        result_str = str(data)
        for pattern in dangerous_patterns:
            if pattern in result_str:
                assert False, f"CRITICAL: Dangerous pattern '{pattern}' exposed: {pattern}"

    def test_missing_json_security_options(self):
        """
        VULNERABILITY: _safe_json_dumps doesn't use secure JSON options

        This demonstrates missing security configuration.
        """
        # Test data with special characters that could cause issues
        test_data = {
            "script": "<script>alert('xss')</script>",
            "unicode": "测试中文字符",
            "special_chars": "\x00\x01\x02",
            "html": "<img src=x onerror=alert('xss')>"
        }

        result = _safe_json_dumps(test_data)

        print(f"JSON security result: {result}")

        # Should be valid JSON
        try:
            parsed = json.loads(result)
        except json.JSONDecodeError as e:
            assert False, f"Invalid JSON produced: {e}"

        # Should use secure JSON options (if implemented in fix)
        # This is more about ensuring the implementation uses best practices
        assert isinstance(result, str), "Result should be string"


if __name__ == "__main__":
    # Run standalone test
    test_instance = TestJSONSerializationVulnerability()

    try:
        test_instance.test_unsafe_dict_serialization_exposes_internal_state()
        print("✅ Dict serialization test PASSED")
    except AssertionError as e:
        print(f"❌ Dict serialization test FAILED: {e}")

    try:
        test_instance.test_error_type_exposes_internal_details()
        print("✅ Error type test PASSED")
    except AssertionError as e:
        print(f"❌ Error type test FAILED: {e}")

    try:
        test_instance.test_sensitive_key_filtering_missing()
        print("✅ Key filtering test PASSED")
    except AssertionError as e:
        print(f"❌ Key filtering test FAILED: {e}")