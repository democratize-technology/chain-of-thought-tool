#!/usr/bin/env python3
"""
Tests for input validation bypass vulnerabilities in validators.py.

This test file demonstrates potential bypass attacks that could circumvent
current validation logic in chain_of_thought/validators.py lines 160-173.

Key vulnerabilities identified:
1. Type confusion via numpy/scipy numeric types
2. Boolean bypass via truthy values
3. List/tuple bypass for array parameters
4. String encoding bypasses
5. Nested structure injection
6. Memory exhaustion via large nested structures
7. Regex bypass via unicode characters
8. HTML escaping bypass techniques
"""

import pytest
import math
import re
import html
from chain_of_thought.validators import ParameterValidator


class TestInputValidationBypassVulnerabilities:
    """Tests that demonstrate bypass vulnerabilities in input validation."""

    def setup_method(self):
        """Set up test fixtures."""
        self.validator = ParameterValidator()

    # ========== CONFIDENCE VALIDATION BYPASS TESTS ==========

    def test_confidence_numpy_type_bypass(self):
        """Test bypass via numpy numeric types that behave like floats but aren't detected."""
        try:
            import numpy as np

            # Test numpy float64 - should now be rejected due to strict type checking
            np_confidence = np.float64(0.8)
            with pytest.raises(ValueError, match="confidence must be a number"):
                self.validator.validate_confidence_param(np_confidence)

            # Test numpy int32 - should be rejected
            np_confidence_int = np.int32(80)
            with pytest.raises(ValueError, match="confidence must be a number"):
                self.validator.validate_confidence_param(np_confidence_int)

        except ImportError:
            pytest.skip("numpy not available")

    def test_confidence_decimal_bypass(self):
        """Test bypass via Decimal type which can behave differently from float."""
        try:
            from decimal import Decimal, InvalidOperation

            # Decimal precision might allow bypassing range checks
            precise_confidence = Decimal('0.9999999999999999999999999999')
            result = self.validator.validate_confidence_param(float(precise_confidence))
            assert 0.0 <= result <= 100.0

            # Very large decimal that might overflow conversion
            large_decimal = Decimal('1E1000')  # This will convert to inf
            with pytest.raises(ValueError):
                self.validator.validate_confidence_param(float(large_decimal))

        except ImportError:
            pytest.skip("decimal module not available")

    def test_confidence_string_coercion_bypass(self):
        """Test bypass via strings that can be coerced to numbers."""
        # These should fail but let's verify they do
        with pytest.raises(ValueError):
            self.validator.validate_confidence_param("0.8")  # String that looks like number

        with pytest.raises(ValueError):
            self.validator.validate_confidence_param("NaN")  # String NaN

        with pytest.raises(ValueError):
            self.validator.validate_confidence_param("inf")  # String infinity

    def test_confidence_nan_bypass_attempts(self):
        """Test various NaN bypass attempts."""
        # Standard NaN
        with pytest.raises(ValueError):
            self.validator.validate_confidence_param(float('nan'))

        # Math NaN
        with pytest.raises(ValueError):
            self.validator.validate_confidence_param(math.nan)

        # NaN via different operations
        with pytest.raises(ValueError):
            self.validator.validate_confidence_param(float('inf') * 0)

    def test_confidence_infinity_bypass_attempts(self):
        """Test various infinity bypass attempts."""
        # Positive infinity
        with pytest.raises(ValueError):
            self.validator.validate_confidence_param(float('inf'))

        # Negative infinity
        with pytest.raises(ValueError):
            self.validator.validate_confidence_param(float('-inf'))

        # Math infinity
        with pytest.raises(ValueError):
            self.validator.validate_confidence_param(math.inf)

        # Infinity via division - use try/except to handle ZeroDivisionError
        try:
            inf_result = 1.0 / 0.0
            with pytest.raises(ValueError):
                self.validator.validate_confidence_param(inf_result)
        except ZeroDivisionError:
            # Expected behavior - Python raises ZeroDivisionError before we get infinity
            pass

    # ========== THOUGHT PARAMETER BYPASS TESTS ==========

    def test_thought_unicode_bypass(self):
        """Test bypass via unicode characters that might evade validation."""
        # Unicode whitespace that might not be caught by strip()
        unicode_spaces = '\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2028\u2029'
        thought_with_unicode_spaces = f'Normal thought{unicode_spaces}with hidden spaces'

        result = self.validator.validate_thought_param(thought_with_unicode_spaces)

        # Check if dangerous unicode characters are preserved
        dangerous_chars = ['\u200B', '\u2028', '\u2029']  # Zero-width space, line separator, paragraph separator
        for char in dangerous_chars:
            if char in result:
                pytest.fail(f"Dangerous unicode character {repr(char)} not removed by validation")

    def test_thought_html_escaping_bypass(self):
        """Test HTML escaping bypass techniques."""
        # Test various XSS bypass attempts
        xss_attempts = [
            '<script>alert("xss")</script>',
            '<img src=x onerror=alert("xss")>',
            '<svg onload=alert("xss")>',
            'javascript:alert("xss")',
            '<iframe src="javascript:alert(\'xss\')"></iframe>',
            '<body onload=alert("xss")>',
            '<input onfocus=alert("xss") autofocus>',
            '<select onfocus=alert("xss") autofocus>',
            '<textarea onfocus=alert("xss") autofocus>',
            '<keygen onfocus=alert("xss") autofocus>',
            '<video><source onerror="alert(\'xss\')">',
            '<audio src=x onerror=alert("xss")>',
            '<details open ontoggle=alert("xss")>',
            '<marquee onstart=alert("xss")>',
            '"><script>alert("xss")</script>',
            "'><script>alert('xss')</script>",
        ]

        for xss_attempt in xss_attempts:
            result = self.validator.validate_thought_param(xss_attempt)

            # Verify HTML escaping worked
            assert '<' not in result or '&lt;' in result
            assert '>' not in result or '&gt;' in result
            assert '"' not in result or '&quot;' in result
            assert "'" not in result or '&#x27;' in result

    def test_thought_length_bypass_via_encoding(self):
        """Test length limit bypass via encoding tricks."""
        # Create a string that's longer than 10,000 characters when measured one way
        # but might bypass simple length checks
        long_thought = 'a' * 10001  # Just over the limit

        with pytest.raises(ValueError, match="cannot exceed 10,000 characters"):
            self.validator.validate_thought_param(long_thought)

        # Test with combining characters that might count differently
        combining_thought = 'a\u0301' * 10001  # 'a' with combining acute accent

        with pytest.raises(ValueError, match="cannot exceed 10,000 characters"):
            self.validator.validate_thought_param(combining_thought)

    # ========== REASONING STAGE BYPASS TESTS ==========

    def test_reasoning_stage_regex_bypass(self):
        """Test regex validation bypass for reasoning_stage."""
        # Test various bypass attempts
        bypass_attempts = [
            'Analysis\n',  # Newline character
            'Analysis\r',  # Carriage return
            'Analysis\t',  # Tab character
            'Analysis ',   # Multiple spaces
            ' Analysis',   # Leading space
            'Analysis ',   # Trailing space (should be stripped)
            'Analysis  ',  # Multiple trailing spaces
            'A n a l y s i s',  # Internal spaces
            'Analysis!@#',  # Special characters
            'Analysis\x00',  # Null byte
            'Analysis\u2028',  # Line separator
            'Analysis\u2029',  # Paragraph separator
        ]

        for attempt in bypass_attempts:
            try:
                result = self.validator.validate_reasoning_stage_param(attempt)
                # If it passes validation, make sure it's actually safe
                assert '\n' not in result, f"Newline in result: {repr(result)}"
                assert '\r' not in result, f"Carriage return in result: {repr(result)}"
                assert '\t' not in result, f"Tab in result: {repr(result)}"
                assert '\x00' not in result, f"Null byte in result: {repr(result)}"
            except ValueError:
                # Expected to fail, which is good
                pass

    def test_reasoning_stage_unicode_spoofing(self):
        """Test unicode characters that look like allowed characters."""
        # Unicode characters that look like ASCII but aren't
        spoofing_attempts = [
            'Ａｎａｌｙｓｉｓ',  # Full-width characters
            'Аnalуsis',     # Cyrillic characters that look like Latin
            'Αnalysis',     # Greek characters that look like Latin
            'Anālysis',     # Macron
            'Anälysis',     # Umlaut
            'Análysis',     # Acute accent
        ]

        for attempt in spoofing_attempts:
            # Check if the unicode normalization is working
            try:
                result = self.validator.validate_reasoning_stage_param(attempt)
                # If it passes validation, the unicode normalization must have converted it
                # to ASCII characters that match the regex. This is the expected behavior.
                # Verify the result is valid ASCII
                assert all(ord(c) < 128 for c in result), f"Result contains non-ASCII: {repr(result)}"
            except ValueError:
                # If it fails validation, that's also acceptable - the spoofing was blocked
                pass

    # ========== STEP PARAMETER BYPASS TESTS ==========

    def test_step_parameters_numeric_bypass(self):
        """Test numeric validation bypass for step parameters."""
        # Test boolean values (should be rejected)
        with pytest.raises(ValueError):
            self.validator.validate_step_parameters(True, 5)

        with pytest.raises(ValueError):
            self.validator.validate_step_parameters(False, 5)

        # Test string numbers (should be rejected)
        with pytest.raises(ValueError):
            self.validator.validate_step_parameters("5", 10)

        # Test float values (should be rejected)
        with pytest.raises(ValueError):
            self.validator.validate_step_parameters(5.0, 10)

        # Test None values (should be rejected)
        with pytest.raises(ValueError):
            self.validator.validate_step_parameters(None, 10)

    def test_step_parameters_extreme_values(self):
        """Test extreme value bypass attempts."""
        import sys
        max_size = sys.maxsize

        # Test boundary values with new, more permissive limits
        self.validator.validate_step_parameters(-10000, 10000000)  # Should pass
        self.validator.validate_step_parameters(10000000, 10000000)  # Should pass
        self.validator.validate_step_parameters(max_size, max_size)  # Should pass

        # Test beyond sys.maxsize (should fail)
        with pytest.raises(ValueError):
            self.validator.validate_step_parameters(max_size + 1, 10)

        # Test below -sys.maxsize (should fail)
        with pytest.raises(ValueError):
            self.validator.validate_step_parameters(-max_size - 1, 10)

    # ========== BOOLEAN PARAMETER BYPASS TESTS ==========

    def test_boolean_parameter_bypass_attempts(self):
        """Test boolean parameter validation bypass attempts."""
        # Test various truthy/falsy values that should be rejected
        bypass_attempts = [
            1,        # Integer
            0,        # Integer
            "True",   # String
            "False",  # String
            "true",   # String
            "false",  # String
            1.0,      # Float
            0.0,      # Float
            [],       # Empty list (falsy)
            [],       # Non-empty list (truthy)
            {},       # Empty dict (falsy)
            {"a": 1}, # Non-empty dict (truthy)
            None,     # None
        ]

        for attempt in bypass_attempts:
            with pytest.raises(ValueError):
                self.validator.validate_boolean_param(attempt, "test_param")

    # ========== LIST PARAMETER BYPASS TESTS ==========

    def test_list_parameter_type_bypass(self):
        """Test list parameter validation via non-list types."""
        # Test various iterable types that aren't lists
        bypass_attempts = [
            (1, 2, 3),        # Tuple
            {1, 2, 3},        # Set
            {1: 'a', 2: 'b'}, # Dict
            "123",            # String (iterable)
            range(3),         # Range
            (x for x in [1, 2, 3]),  # Generator
        ]

        for attempt in bypass_attempts:
            with pytest.raises(ValueError, match="must be a list"):
                self.validator.validate_integer_list_param(attempt, "test_param")

    def test_list_parameter_nested_bypass(self):
        """Test list validation bypass via nested structures."""
        # Test with nested lists that might cause issues
        nested_lists = [
            [1, [2, 3], 4],     # Nested list
            [1, (2, 3), 4],     # Tuple in list
            [1, {2, 3}, 4],     # Set in list
            [1, None, 3],       # None in list
            [1, "2", 3],        # String in integer list
            [1, 2.0, 3],        # Float in integer list
            [1, True, 3],       # Boolean in integer list
        ]

        for nested_list in nested_lists:
            with pytest.raises(ValueError):
                self.validator.validate_integer_list_param(nested_list, "test_param")

    def test_list_parameter_memory_exhaustion_bypass(self):
        """Test memory exhaustion via large lists."""
        # Test with extremely large lists that might cause memory issues
        large_list = list(range(100))  # This should work

        # Test with list that exceeds max_items
        too_large = list(range(51))  # Exceeds default max_items=50
        with pytest.raises(ValueError, match="cannot exceed 50 items"):
            self.validator.validate_integer_list_param(too_large, "test_param")

    # ========== COMPREHENSIVE BYPASS ATTEMPTS ==========

    def test_comprehensive_bypass_attempt_malicious_request(self):
        """Test a comprehensive malicious request with multiple bypass attempts."""
        malicious_input = {
            "thought": '<script>alert("xss")</script>Normal thought with hidden chars\u200b\u2028',
            "step_number": 5,
            "total_steps": 10,
            "next_step_needed": 1,  # Integer instead of boolean
            "reasoning_stage": "Analysis\n\r\t",  # With whitespace chars
            "confidence": float('nan'),  # NaN value
            "dependencies": [1, 2, "3", None, [5]],  # Mixed types
            "contradicts": [1.0, "2", True],  # Wrong types
            "evidence": ["<script>alert('xss')</script>", "Normal evidence"],
            "assumptions": ["Assumption\x00with null byte", "Normal"]
        }

        # This should fail validation at multiple points
        with pytest.raises(ValueError):
            self.validator.validate_input(**malicious_input)

    def test_input_validation_robustness_edge_cases(self):
        """Test edge cases that might break validation logic."""
        edge_cases = [
            # Empty and None values
            {"thought": "", "step_number": 1, "total_steps": 1, "next_step_needed": True},
            {"thought": None, "step_number": 1, "total_steps": 1, "next_step_needed": True},

            # Extreme values
            {"thought": "a" * 10000, "step_number": 10000000, "total_steps": 10000000, "next_step_needed": True},

            # Boundary conditions
            {"thought": "a", "step_number": 0, "total_steps": 0, "next_step_needed": True},
            {"thought": "a", "step_number": 1, "total_steps": 1, "next_step_needed": True},
        ]

        for case in edge_cases:
            try:
                result = self.validator.validate_input(**case)
                # If it succeeds, verify the result is safe
                assert isinstance(result, dict)
                assert "thought" in result
                assert "step_number" in result
                assert "total_steps" in result
                assert "next_step_needed" in result
            except ValueError:
                # Expected to fail in some cases
                pass